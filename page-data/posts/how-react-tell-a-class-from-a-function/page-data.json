{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/how-react-tell-a-class-from-a-function/","result":{"data":{"markdownRemark":{"id":"33f51250-cbf6-50da-b051-011ace32af60","html":"<p>原文: <a href=\"https://overreacted.io/how-does-react-tell-a-class-from-a-function/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">How Does React Tell a Class from a Function?</a></p>\n<p>下面这个 <code class=\"language-text\">Greeting</code> 是一个函数式 React 组件:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>React 同样支持以类的形式定义一个组件:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>(函数式组件可以通过 <a href=\"https://reactjs.org/docs/hooks-intro.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">hooks</a> 保存状态)</p>\n<p>不过当我们使用一个组件的时候, 我们并不在意它是如何定义的:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Class or function — whatever.</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Greeting</span></span> <span class=\"token punctuation\">/></span></span></code></pre></div>\n<p>不过 React 本身对组件是函数式还是类式, 十分在意.</p>\n<p>如果 <code class=\"language-text\">Greeting</code> 是函数式组件, React 的使用方式就是调用它:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Your code</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Inside React</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>如果 <code class=\"language-text\">Greeting</code> 是类式组件, React 的使用方式就是使用 <code class=\"language-text\">new</code> 操作符来实例化这个组件, 并调用所创建实例的 <code class=\"language-text\">render</code> 方法.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Your code</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Inside React</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting {}</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>以上两种情况下, React 的目标都是获取需要被渲染的 DOM 节点(在我们的例子中是 <code class=\"language-text\">&lt;p&gt;Hello&lt;/p&gt;</code> ). 具体的获取步骤, 还是根据 <code class=\"language-text\">Greeting</code> 如何被定义来决定.</p>\n<p><strong>那么 React 是如何知道组件是类还是函数的呢?</strong></p>\n<p>就像我在<a href=\"https://overreacted.io/why-do-we-write-super-props/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这篇文章</a>中说的, 即使不知道这点, <strong>你也能够高效地用 React 构建出 web 应用.</strong> 我也并不是一开始就了解这个知识的, 因此请不要将这个知识点作为面试题询问求职者. 实际上, 这篇文章所涉及的知识更偏向于 JavaScript 而不是 React.</p>\n<p>这篇文章的目标读者是对 React 的底层原理有好奇心的开发者, 如果你是的话, 那么就让我们一起探索吧.</p>\n<p><strong>我们的探索旅程会很长. 请系好安全带. 本文涉及到的 React 知识点其实并不多, 更多的是关于 JavaScript 的知识点, 比如说: <code class=\"language-text\">new</code> , <code class=\"language-text\">this</code> , <code class=\"language-text\">class</code> , 箭头函数, <code class=\"language-text\">prototype</code> , <code class=\"language-text\">__proto__</code>, <code class=\"language-text\">instanceof</code> 等. 幸运的是, 当你在使用 React 的时候, 并不需要特别考虑这些. 不过站在 React 的开发者角度, 情况就不一样了…</strong></p>\n<p>(如果你不希望了解实现细节, 只想要知道答案, 请直接查看文末的内容.)</p>\n<hr>\n<p>首先我们需要理解, 为什么区别对待函数式组件和类组件是重要的. 当我们调用类组件时候, 需要依赖 <code class=\"language-text\">new</code> 操作符:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 如果 Greeting 是函数式组件, 在react内部会被这样调用</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span>\n<span class=\"token comment\">// 如果 Greeting 是 class 组件, 在react内部会被这样调用</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting {}</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> instance<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// &lt;p>Hello&lt;/p></span></code></pre></div>\n<p>现在我们重点关注一下, <code class=\"language-text\">new</code> 操作符在 JavaScript 中具体做了些什么.</p>\n<hr>\n<p>过去 JavaScript 中没有类的概念. 但是我们可以构造一个与类有类似功能的函数. 具体见下面的例子, 针对这种特殊的函数, 我们使用 <code class=\"language-text\">new</code>关键字进行调用.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 只是一个函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Person {name: 'Fred'}</span>\n<span class=\"token keyword\">var</span> george <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴 不会起作用, </span>\n<span class=\"token comment\">// 如果将代码在控制台执行, 会发现 this 指向全局 window.name 是 George</span></code></pre></div>\n<p>如果我们调用 <code class=\"language-text\">Person(&#39;Fred&#39;)</code> 时没有加上 <code class=\"language-text\">new</code> 关键字, 函数中的 <code class=\"language-text\">this</code> 会指向全局, 那么这个 <code class=\"language-text\">this</code> 就一点意义也没有了. 我们的代码会崩溃, 同时还做了件蠢事: 创建了一个无用的全局变量.</p>\n<p><strong>那么使用 <code class=\"language-text\">new</code> 调用函数时具体发生了些什么呢?</strong></p>\n<p>在调用函数时添加<code class=\"language-text\">new</code>, 相当于告诉 JavaScript, <code class=\"language-text\">Person</code>虽然只是个函数, 但是我们可以把它看做类构造器. <strong>此时 JavaScript 就会创建一个<code class=\"language-text\">{}</code>对象, 然后<code class=\"language-text\">Person</code>中的<code class=\"language-text\">this</code>值指向该对象, 同时将 <code class=\"language-text\">name</code> 设置为该对象的属性, 并且 <code class=\"language-text\">return</code> 出该对象.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Same object as `this` inside `Person`</span></code></pre></div>\n<p>通过以上的 <code class=\"language-text\">new</code> 调用, 对象 <code class=\"language-text\">fred</code> 还可以读取构造器函数 <code class=\"language-text\">Person.prototype</code> 上的属性.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在 JavaScript 不原生支持<code class=\"language-text\">class</code>之前, 开发者就是通过这种方式模拟类的.</p>\n<hr>\n<p><code class=\"language-text\">new</code> 关键字存在已久, 而 <code class=\"language-text\">class</code> 的支持却是近段时间的事. 现在我们使用<code class=\"language-text\">class</code>改写先前的代码.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>在设计编程语言和 API 时, 用户的痛点至关重要.</p>\n<p>开发者在编写函数时, JavaScript 无法猜测到函数是需要被直接调用还是在之前加关键词 <code class=\"language-text\">new</code> 调用.  因此开发者在调用类似 <code class=\"language-text\">Person</code> 这样的构造函数时, 务必记得在前面添加 <code class=\"language-text\">new</code> 关键字, 否则就会给程序引入一些令人疑惑的问题.</p>\n<p><strong>有了 Class 语法之后, 我们的语境中就有了类的概念, 对于这类特殊的函数, 我们就能说, 它不仅仅是一个函数, 而是一个类, 同时有自己的构造函数.</strong> 如果你在调用它的时候忘了加上 <code class=\"language-text\">new</code> 关键字, JavaScript 就会抛出错误.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// ✅  If Person is a function: works fine</span>\n<span class=\"token comment\">// ✅  If Person is a class: works fine too</span>\n\n<span class=\"token keyword\">let</span> george <span class=\"token operator\">=</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// We forgot `new`</span>\n<span class=\"token comment\">// 😳 If Person is a constructor-like function: confusing behavior</span>\n<span class=\"token comment\">// 🔴 If Person is a class: fails immediately</span></code></pre></div>\n<p>这样一来, 我们就避免写出造成许多隐藏bug的代码, 比如 <code class=\"language-text\">this.name</code> 被当作是 <code class=\"language-text\">window.name</code> 而不是我们所预期的 <code class=\"language-text\">george.name</code> .</p>\n<p>不过如果 React 也必须遵循这个原则的话, 那么在调用任何类组件的时候, 就必须在之前加上 <code class=\"language-text\">new</code> 关键字, 否则的话 JavaScript 就会抛出异常.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Counter</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 🔴 React 无法这样做</span>\n<span class=\"token keyword\">const</span> instance <span class=\"token operator\">=</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<hr>\n<p>那么 React 是如何解决这个问题的呢? 大多数开发者在使用React时会同时使用<code class=\"language-text\">Babel</code> 来编译最新语法的代码以兼容旧版本的浏览器. 因此我们把解决方案的头绪放在了编译器上.</p>\n<p>在前几个版本的 <code class=\"language-text\">Babel</code> 中, 类可以不需要声明 <code class=\"language-text\">new</code> 关键字直接调用, 但是这个问题很快被 <code class=\"language-text\">Babel</code> 团队修复了, 我们来看一下他们的修复方式:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// A bit simplified from Babel output:</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TypeError</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cannot call a class as a function\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// Our code:</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Okay</span>\n<span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'George'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 🔴 Cannot call a class as a function</span></code></pre></div>\n<p>如果你看过项目打包之后的代码的话, 可能会觉得这个函数似曾相识, 这个就是<code class=\"language-text\">_classCallCheck</code> 函数所做的事情. (你可以通过开启”宽松检查模式”来减少打包之后代码的量, 但是这当然也带来了一个问题: 当处理真正的原生类语法时, 情况会变得更加复杂. You can reduce the bundle size by opting into the “loose mode” with no checks but this might complicate your eventual transition to real native classes.)</p>\n<hr>\n<p>至此, 我们明白了调用函数时加 <code class=\"language-text\">new</code> 与不加 <code class=\"language-text\">new</code> 的区别:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 960px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/8f85f250c2e88ac0c3065d7bf92aec5f/b1584/compare.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.500000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABAklEQVQY02VR7W7DIBDL+7/h9mfr1KYtCd85CARwD7Z10gqylNjGdwdTaw19Nd45R6RESDuh1YIudf3paXVoKYUn939N38Z+EnBSQNw+cb9+oJT8Yi5c5L6csdy/flr4K/iLKZDuLHLNOIUTQnCMiBgsiAyklLDWoLCnMp9uM2J02NlXuUCt9YkR6Ow6qh8sznSGNQLOWXTeWcWBCkZr1B4Yd9B8Ye4K8uplgj7oZPQNkSyOVvDu3kZg78i7lSEhhIBSijvoI2WE7cK8HlDrhf0KSs7j+zgSps1Lvugw7meJArRpHpXGyIEch1t471mv46FSMOzpmsfG3hiI/804V46MB8vY0kxbv2tSAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/blog/static/8f85f250c2e88ac0c3065d7bf92aec5f/8ac56/compare.webp 240w,\n/blog/static/8f85f250c2e88ac0c3065d7bf92aec5f/d3be9/compare.webp 480w,\n/blog/static/8f85f250c2e88ac0c3065d7bf92aec5f/e46b2/compare.webp 960w,\n/blog/static/8f85f250c2e88ac0c3065d7bf92aec5f/ec5ae/compare.webp 1342w\"\n              sizes=\"(max-width: 960px) 100vw, 960px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/blog/static/8f85f250c2e88ac0c3065d7bf92aec5f/8ff5a/compare.png 240w,\n/blog/static/8f85f250c2e88ac0c3065d7bf92aec5f/e85cb/compare.png 480w,\n/blog/static/8f85f250c2e88ac0c3065d7bf92aec5f/d9199/compare.png 960w,\n/blog/static/8f85f250c2e88ac0c3065d7bf92aec5f/b1584/compare.png 1342w\"\n            sizes=\"(max-width: 960px) 100vw, 960px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/blog/static/8f85f250c2e88ac0c3065d7bf92aec5f/d9199/compare.png\"\n            alt=\"compare\"\n            title=\"compare\"\n            loading=\"lazy\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>这就是为什么, 在React中, 正确调用组件是多么重要. <strong>如果组件被定义为类组件, React必须在前添加 <code class=\"language-text\">new</code> 关键字进行调用.</strong></p>\n<p>那么 React 是否可以不依赖任何其他信息区分出组件是函数式组件还是class组件呢?</p>\n<p>并不简单. 虽然我们<a href=\"https://stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">在 JavaScript 中可以区分出 class 函数和普通函数</a>, 但是被 <code class=\"language-text\">Babel</code> 处理过的代码, 就很难区分了. 因为经过处理之后, 对于浏览器来说, 它们都是普通的函数. 不过在 React 中, 我们还是有办法处理的.</p>\n<hr>\n<p>或许 React 可以针对每一次调用都加上 <code class=\"language-text\">new</code> 关键字? 遗憾的事, 这样的方式并不靠谱. </p>\n<p>调用普通函数时添加 <code class=\"language-text\">new</code> 关键字会为该函数创建一个对象实例. 针对构造器函数, 使用 <code class=\"language-text\">new</code> 调用是预期行为, 但是针对函数式组件, 这种调用方式就会让人觉得疑惑.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// We wouldn’t expect `this` to be any kind of instance here</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>以上这个原因并没有到不能接受的程度, 但是还有其他两个重要原因决定了不可以始终添加 <code class=\"language-text\">new</code> 关键词进行函数调用.</p>\n<hr>\n<p>第一个原因是使用 <code class=\"language-text\">new</code> 调用箭头函数(未被 Babel 编译过) 会抛出异常:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Greeting</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🔴 Greeting is not a constructor</span></code></pre></div>\n<p>由于不符合箭头函数的设计语法, JavaScript 有意限制了这种行为. 箭头函数最主要的特点之一是没有自己的 <code class=\"language-text\">this</code> , 如果在箭头函数内部使用 <code class=\"language-text\">this</code> 的话, <code class=\"language-text\">this</code> 的值会由离它最近的普通函数决定.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Friends</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> friends <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>friends<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> friends<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">friend</span> <span class=\"token operator\">=></span>\n      <span class=\"token operator\">&lt;</span>Friend\n        <span class=\"token comment\">// `this` is resolved from the `render` method</span>\n        size<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">}</span>\n        name<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>friend<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span>\n        key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>friend<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span>\n      <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>箭头函数没有自己的 <code class=\"language-text\">this</code>. 因此我们没有办法将箭头函数改造为构造器函数.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Person</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 🔴 This wouldn’t make sense!</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>JavaScript</strong> 禁止了使用 <code class=\"language-text\">new</code> 调用箭头函数的行为. 也是由于同样的原因, 我们必须使用 <code class=\"language-text\">new</code> 关键词实例化一个类. </p>\n<p>因此, 在React中用 <code class=\"language-text\">new</code> 调用函数是不合理的. 那么针对这种情况, 我们是否可以检测出函数是否为箭头函数(如果没有 <code class=\"language-text\">prototype</code> , 则非箭头函数), 然后针对它做些特殊处理 (不要用 <code class=\"language-text\">new</code> 去调用它).</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// {constructor: f}</span></code></pre></div>\n<p>但是函数经过Babel编译之后, 就<a href=\"https://github.com/facebook/react/issues/4599#issuecomment-136562930\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">不能够用以上的方式判断</a>了. 编译之后的结果:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token string\">\"use strict\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">;</span> </code></pre></div>\n<p>不过这个问题比较好解决, 影响比较严重的是另一个原因:</p>\n<hr>\n<p>当函数的返回值是字符串或其他原始类型时, 使用 <code class=\"language-text\">new</code> 对其进行调用不会得到我们预期的结果.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 'Hello'</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Greeting {}</span></code></pre></div>\n<p>这个行为和 <code class=\"language-text\">new</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">操作符</a>本身的设计有关. 在前文中我们知道, <code class=\"language-text\">new</code> 会告诉 JavaScript 引擎创建一个对象,  <code class=\"language-text\">this</code> 指向所创建的对象实例, 然后 <code class=\"language-text\">return</code> 出该实例.</p>\n<p>JavaScript  同样允许函数被 <code class=\"language-text\">new</code> 调用时, 通过控制 <code class=\"language-text\">return</code> 的值来覆盖默认返回的对象.  当在对象池模式下, 想要复用函数实例时, 这种模式就可以发挥作用了. </p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Created lazily</span>\n<span class=\"token keyword\">var</span> zeroVector <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">,</span> y</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> y <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>zeroVector <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Reuse the same instance</span>\n      <span class=\"token keyword\">return</span> zeroVector<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    zeroVector <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>x <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>y <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Vector</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😲 b === c</span></code></pre></div>\n<p>不过有一点需要注意的是, 当手动 <code class=\"language-text\">return</code> 出的不是对象, 而是字符串或者数字类型, 这些值就无法覆盖默认的对象.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">42</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ 42</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Answer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Answer {}</span></code></pre></div>\n<p>因此, 如果始终用 <code class=\"language-text\">new</code> 调用函数, <code class=\"language-text\">React</code> 就永远无法支持返回值为数字或者字符串的组件了.</p>\n<p>由于这个原因, 我们必须做出一些妥协.</p>\n<hr>\n<p>至此我们学到了: React 针对类组件调用时(包括经过 Babel 处理的结果), 需要添加 <code class=\"language-text\">new</code> 关键字, 但是普通函数和箭头函数调用却不需要. 可是到目前为止并没有可靠的方法对这两种方式进行区分.</p>\n<p><strong>不过我们是否可以转换看问题的角度, 针对通用的问题我们没有办法解决, 那么是不是可以找到一个更具体的问题去解决. If we can’t solve a general problem, can we solve a more specific one?</strong> </p>\n<p>当我们定义一个 React 类组件时, 该组件一定会继承 <code class=\"language-text\">React.Component</code> 以便使用 React 的内部方法 <code class=\"language-text\">this.setState()</code> .  <strong>这样的话, 我们是否就不需要检测所有的类, 只需要检测继承 <code class=\"language-text\">React.Component</code> 的组件即可?</strong></p>\n<p>剧透: 这就是React的处理方式.</p>\n<hr>\n<p>现在我们要检测 <code class=\"language-text\">Greeting</code> 是否是一个React 类组件, 最符合直觉的检测方式是 <code class=\"language-text\">Greeting.prototype instanceof React.Component</code> :</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">B</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">A</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">B</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">A</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span></code></pre></div>\n<p>为了理解以上代码的含义, 我们首先要理解 JavaScript 原型.  </p>\n<p>大家对”原型链”这个概念应该已经很熟悉了. 在JavaScript中, 所有对象可能存在一个”原型”. 当我们执行这段代码 <code class=\"language-text\">fred.sayHi()</code> 时, <code class=\"language-text\">fred</code> 这个对象本身可能并不存在 <code class=\"language-text\">sayHi</code> 属性. 我们会从 <code class=\"language-text\">fred</code> 的原型上寻找这个属性. 如果没有找到, 则会再深入原型链寻找 — <code class=\"language-text\">fred</code> 的原型的原型. 直到找到这个属性为止.</p>\n<p>但比较令人疑惑的一点是, 类或者函数的 <code class=\"language-text\">prototype</code> 属性与它的原型并不对等.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 🤪 Not Person's prototype</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Person<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 😳 Person's prototype</span></code></pre></div>\n<p>原型链的结构是 <code class=\"language-text\">__proto__.__proto__.__proto__</code> 而不是 <code class=\"language-text\">prototype.prototype.prototype</code> .</p>\n<p>那这个 <code class=\"language-text\">prototype</code> 属性是什么呢?  当我们用 <code class=\"language-text\">new</code> 实例化一个类或者函数时, 实例的 <code class=\"language-text\">__proto__</code> 属性就是就是类或函数的 <code class=\"language-text\">prototype</code> 属性.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sayHi</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">alert</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hi, I am '</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> fred <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fred'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Sets `fred.__proto__` to `Person.prototype`</span></code></pre></div>\n<p>JavaScript使用<strong><code class=\"language-text\">__proto__</code></strong> 链查询属性:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">fred<span class=\"token punctuation\">.</span><span class=\"token function\">sayHi</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1. Does fred have a sayHi property? No.</span>\n<span class=\"token comment\">// 2. Does fred.__proto__ have a sayHi property? Yes. Call it!</span>\n\nfred<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 1. Does fred have a toString property? No.</span>\n<span class=\"token comment\">// 2. Does fred.__proto__ have a toString property? No.</span>\n<span class=\"token comment\">// 3. Does fred.__proto__.__proto__ have a toString property? Yes. Call it!</span></code></pre></div>\n<p>不过在实际应用中, 你不应该直接使用 <code class=\"language-text\">__proto__</code> , 除非调试时需要查询与原型链相关的信息. 如果你想使某些属性可以利用 <code class=\"language-text\">fred.__proto__</code> 访问, 就应该将该信息放在 <code class=\"language-text\">Person.prototype</code> . 这也是 <code class=\"language-text\">prototype</code> 设计的初衷.</p>\n<p><code class=\"language-text\">__proto__</code> 属性其实并不应该暴露给外部, 因为它本质上只给 JavaScript 内部使用. 但是某些浏览器依然支持了该属性甚至将其标准化(不过它会逐渐被 <code class=\"language-text\">Object.getPrototypeOf()</code> 所替代的.)</p>\n<p><strong>现在我依然疑惑的是: 对象的 <code class=\"language-text\">prototype</code> 属性对应的值竟然不是对象的原型</strong>(举个例子: <code class=\"language-text\">fred.prototype</code> 的值为 <code class=\"language-text\">undefined</code> , 因为 <code class=\"language-text\">fred</code> 不是一个函数). 个人认为, 这是开发者难以理解 JavaScript 原型概念的主要原因.</p>\n<hr>\n<p>现在我们知道了, 当我们输入 <code class=\"language-text\">obj.foo</code> 时, JavaScript 实际上会在 <code class=\"language-text\">obj</code> <code class=\"language-text\">obj.__proto__</code>, <code class=\"language-text\">obj.__proto__.__proto__</code> …上寻找 <code class=\"language-text\">foo</code> 属性.</p>\n<p>在 JavaScript 类中, 并没有直接暴露这个机制, 不过 <code class=\"language-text\">extends</code> 的实现基于这种原型链机制. 这也是我们的 React 类实例读取 <code class=\"language-text\">setState</code> 方法所利用的机制:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Greeting.prototype</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// React.Component.prototype</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">.</span>__proto__<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Object.prototype</span>\n\nc<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">// Found on c.__proto__ (Greeting.prototype)</span>\nc<span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// Found on c.__proto__.__proto__ (React.Component.prototype)</span>\nc<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// Found on c.__proto__.__proto__.__proto__ (Object.prototype)</span></code></pre></div>\n<p>也就是说, <strong>当我们使用类的时候, 类实例的 <code class=\"language-text\">__proto__</code> 链反映了这种原型链关系:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// `extends` chain</span>\nGreeting\n  → React<span class=\"token punctuation\">.</span>Component\n    → <span class=\"token function\">Object</span> <span class=\"token punctuation\">(</span>implicitly<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// `__proto__` chain</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  → <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype\n    → React<span class=\"token punctuation\">.</span><span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype\n      → <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype</code></pre></div>\n<p>那么既然了解了 <code class=\"language-text\">__proto__</code> 链的概念, 我们就能通过这种方式检查 <code class=\"language-text\">Greeting</code> 是否继承自 <code class=\"language-text\">React.Component</code> , 从 <code class=\"language-text\">Greeting.prototype</code> 开始通过 <code class=\"language-text\">__proto__</code> 不断层层深入.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// `__proto__` chain</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  → <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// 🕵️ We start here</span>\n    → React<span class=\"token punctuation\">.</span><span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype <span class=\"token comment\">// ✅ Found it!</span>\n      → <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype</code></pre></div>\n<p>还有一个更加方便的方式, <code class=\"language-text\">x instanceof Y</code> 也可以实现与以上代码几乎差不多的功能. 跟着 <code class=\"language-text\">x.__proro__</code> 的原型链寻找 <code class=\"language-text\">Y.prototype</code> .</p>\n<p>正常情况下, 我们通过这种方式来判断类的实例:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">let</span> greeting <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting (🕵️‍ We start here)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype (✅ Found it!)</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype </span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting (🕵️‍ We start here)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype (✅ Found it!)</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// true</span>\n<span class=\"token comment\">// greeting (🕵️‍ We start here)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype (✅ Found it!)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Banana</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// false</span>\n<span class=\"token comment\">// greeting (🕵️‍ We start here)</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype </span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype (🙅‍ Did not find it!)</span></code></pre></div>\n<p>同时也能用来判断某个类是否继承自另一个类:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// greeting</span>\n<span class=\"token comment\">//   .__proto__ → Greeting.prototype (🕵️‍ We start here)</span>\n<span class=\"token comment\">//     .__proto__ → React.Component.prototype (✅ Found it!)</span>\n<span class=\"token comment\">//       .__proto__ → Object.prototype</span></code></pre></div>\n<p>以上这种方式可以用以区分React 类组件和函数组件.</p>\n<hr>\n<p>不过React在生产中并不是使用这种方式去检查的. 😳</p>\n<p>使用 <code class=\"language-text\">instanceof</code> 的判断方式有个弊端, 当我们的页面中存在多个 React 的拷贝时,  我们检查的某个组件可能继承自另一个 React 拷贝的 <code class=\"language-text\">React.Component</code> . 在一个项目中使用多个 React 拷贝当然是不推荐的做法. 但是由于历史原因, 我们可能会用多个 React 拷贝来解决某些问题. (不过如果我们在项目中使用 Hooks 的话, <a href=\"https://github.com/facebook/react/issues/13991\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">我们可能必须要禁止多个拷贝的存在</a>.)</p>\n<p>另一个判断方式是, 检查原型链中的 <code class=\"language-text\">render</code> 方法是否存在. 然而, 当时对于<a href=\"https://github.com/facebook/react/issues/4599#issuecomment-129714112\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">组件相关的 API 规范并没有完全确定下来.</a> 随时可能会变化. 如果使用这种方式的话, Every check has a cost so we wouldn’t want to add more than one. 同时, 如果 <code class=\"language-text\">render</code> 被定义为实例方法的话, 这种方式也会失效.</p>\n<p>因此 React 采用了一种给基础组件<a href=\"https://github.com/facebook/react/pull/4663\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">添加</a>特殊标志的方式. React 会检查这个标志是否存在, 通过这个标志来判断这是个类组件还是函数组件.</p>\n<p>在最初的实现版本中, 这个标志存在于 <code class=\"language-text\">React.Compoenent</code> 本身:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Inside React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nComponent<span class=\"token punctuation\">.</span>isReactClass <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// We can check it like this</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>Greeting<span class=\"token punctuation\">.</span>isReactClass<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Yes</span></code></pre></div>\n<p>然而, 一些类在<a href=\"https://github.com/scala-js/scala-js/issues/1900\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">实现</a>上并没有拷贝静态属性或者设置非标准的 <code class=\"language-text\">__proto__</code> . 在这种情况下 React 添加的特殊标志就丢失了.</p>\n<p>于是React团队<a href=\"https://github.com/facebook/react/pull/5021\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">将这个标志转移</a>到了 <code class=\"language-text\">React.Component.prototype</code> 上了:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Inside React</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token class-name\">Component</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// We can check it like this</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Greeting</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Greeting</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>isReactComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ✅ Yes</span></code></pre></div>\n<p>也许很多人会疑惑, 为什么我们的标识不是布尔值而是对象. 这是因为我们在使用 Jest 进行自动化测试时, 前几个版本的 Jest 默认打开了<a href=\"https://dev.to/slashgear_/discover-jest-hidden-feature-automock-2c9f\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">automocking</a>, 生成的模拟测试数据会<a href=\"https://github.com/facebook/react/pull/4663#issuecomment-136533373\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">忽略原始值</a>, 因此如果用布尔值的话, 会影响自动化测试的结果.</p>\n<p><code class=\"language-text\">isReactComponent</code> 的检测方式至今依然在<a href=\"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L297-L300\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">使用</a>. </p>\n<p>如果你在编写React组件的时候没有继承 <code class=\"language-text\">React.Component</code> . React就不会在原型链中找到 <code class=\"language-text\">isReactComponent</code> 这个属性, 也不会将其看做 class 组件. 读到这里, 大家可能就都明白<a href=\"https://stackoverflow.com/questions/38481857/getting-cannot-call-a-class-as-a-function-in-my-react-project/42680526#42680526\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">这个问题</a>的答案了: 如果在React的开发过程中遇到 <code class=\"language-text\">Cannot call a class as a function</code> 的报错, 记得在使用React 类组件时加上 <code class=\"language-text\">extends React.Component</code> . 同时如果你没有这样使用类组件, 却组件内却定义了 <code class=\"language-text\">render</code> 方法, React也会报出一个<a href=\"https://github.com/facebook/react/pull/11168\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">⚠️</a>. </p>\n<hr>\n<p>你可能会觉得这篇文章有点挂羊头卖狗肉 (<a href=\"https://en.wikipedia.org/wiki/Bait-and-switch\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">bait-and-switch</a>) 的感觉. <strong>实际的解决方案那么简单, 可是我们却不直接回答这个问题, 而是饶了那么一大圈去解释为什么替代方案是不可行的.</strong> </p>\n<p>在我的经验中, 在实现一个库的 API 时, 这是经常会遇到的情况. 对于一个使用起来很方便的 API, 你必须要深入考虑语言本身的语义, 运行时的性能, 存在/不存在编译步骤时的效率, 相关生态的发展以及打包方案, 早期的告警以及很多其他问题. 最终设计出成果或许不会是最优雅的, 但是肯定是最实用的.</p>\n<p>如果最终设计出来的 API 很成功的话, 那么 API 的使用者就完全不需要考虑它的设计过程, 只需要专注于创建应用即可.</p>\n<p>如果使用者对 API 的设计感到好奇, 了解它的底层原理当然是很好的.</p>","headings":[],"fields":{"slug":"/posts/how-react-tell-a-class-from-a-function/","tagSlugs":null},"frontmatter":{"date":"2020-01-15","description":"How Does React Tell a Class from a Function?","tags":null,"title":"React 如何区分类组件和函数式组件?","socialImage":null}}},"pageContext":{"slug":"/posts/how-react-tell-a-class-from-a-function/"}},"staticQueryHashes":["251939775","401334301","825871152"]}