{"componentChunkName":"component---src-templates-blog-js","path":"/react-dnd-overview/","result":{"data":{"site":{"siteMetadata":{"title":"Fish's Blog"}},"markdownRemark":{"id":"ab0a1229-65c7-5ab8-8fca-1c2ac131050b","excerpt":"原文: https://react-dnd.github.io/react-dnd/docs/overview React DnD 与业界其他的拖拽库区别比较大, 如果你以前从来没有用过 React DnD, 上手会比较困难. 不过, 只要你了解了其中一些设计理念之后, 对 DnD…","html":"<p>原文: <a href=\"https://react-dnd.github.io/react-dnd/docs/overview\">https://react-dnd.github.io/react-dnd/docs/overview</a></p>\n<p>React DnD 与业界其他的拖拽库区别比较大, 如果你以前从来没有用过 React DnD, 上手会比较困难. 不过, 只要你了解了其中一些设计理念之后, 对 DnD 的理解和上手就会更容易了. 因此我建议大家在阅读文档的其他部分时, 首先阅读这一部分, 了解一些重要概念.</p>\n<p>React DnD 中某些概念与 <a href=\"http://facebook.github.io/flux/\">Flux</a> 和 <a href=\"https://github.com/reactjs/react-redux\">Redux</a> 类似. 这并非巧合, 它内部使用的就是 Redux.</p>\n<h2 id=\"项目与类型\" style=\"position:relative;\"><a href=\"#%E9%A1%B9%E7%9B%AE%E4%B8%8E%E7%B1%BB%E5%9E%8B\" aria-label=\"项目与类型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>项目与类型</h2>\n<p>与 Flux 或者 Redux 类似的是, React DnD 操作的是数据, 而非视图, 并且只有数据能够控制视图. 当用户在屏幕中拖拽某些部分时, 我们并不将这些部分称为组件或者 DOM 节点, 而是某种类型的 <em>项目</em> (<em>item</em>).</p>\n<p>那么项目是什么呢? 它是一个 JavaScript 对象, 描述了用户正在拖拽的内容. 举个例子, 在看板类的应用中, 用户所拖拽的卡片, 用项目的形式描述就会像是这样 <code class=\"language-text\">{ cardId: 42 }</code>. 在国际象棋游戏中, 当用户拿起一个棋子, 项目可能就是这样 <code class=\"language-text\">{ fromCell: &#39;C5&#39;, piece: &#39;queen&#39; }</code> . <strong>将所拖拽的数据以对象的形式表示有利于组件之间的解耦.</strong></p>\n<p>那么类型又是什么呢? 它是表示一类项目的唯一标识, 由字符串(或者 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\">symbol</a>)表示. 在看板应用中, 会存在一个<code class=\"language-text\">&quot;卡片&quot;</code>类型, 代表所有可拖拽的卡片类项目, 还会存在<code class=\"language-text\">&quot;列表&quot;</code>类型, 代表某些卡片所在的容器区域, 同时这个列表类型也是可拖拽的. 而在国际象棋游戏中, 就只有一个类型: <code class=\"language-text\">&quot;棋子&quot;</code>.</p>\n<p>类型在 dnd 中是一个重要的概念, 当我们的应用规模逐渐扩大之后, 可能会增加更多可拖拽的元素, 但是原来的拖拽目标(区域), 并不需要承载新增的可拖拽元素. <strong>类型使得我们能够声明拖拽部分和容器部分之间的对应关系.</strong> 因此我们就需要事先列举出应用中包含的所有可拖拽类型, 就像在 Redux 中列举出所有 action 一样.</p>\n<h2 id=\"监视器\" style=\"position:relative;\"><a href=\"#%E7%9B%91%E8%A7%86%E5%99%A8\" aria-label=\"监视器 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>监视器</h2>\n<p>拖拽的动作是有状态的. 拖拽的操作要么处于正在进行状态, 要么处于未进行状态. 当前状态的所有者一定属于某个类型, 某个项目.</p>\n<p>React DnD 通过<em>监视器(monitors)</em> 来暴露拖拽的状态. <strong>我们能利用监视器所提供的信息, 更新组件的状态, 以处理拖拽状态的变化.</strong></p>\n<p>对于需要追踪拖拽状态的组件, 用户可以定义一个 <em>收集函数(collecting function)</em> , 通过该函数获取监视器所提供的拖拽状态信息, 并做出对应的处理. React DnD 会在必要的时候调用收集器函数, 并合并返回值, 注入组件的 <code class=\"language-text\">props</code> 中.</p>\n<p>举个具体的例子, 当某个棋子被拖拽时, 我们希望高亮对应棋盘格. 那么棋盘格 <code class=\"language-text\">Cell</code> 组件的收集函数可以这样定义:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">monitor</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    highlighted<span class=\"token operator\">:</span> monitor<span class=\"token punctuation\">.</span><span class=\"token function\">canDrop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    hovered<span class=\"token operator\">:</span> monitor<span class=\"token punctuation\">.</span><span class=\"token function\">isOver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>以上函数会告诉 React DnD, 将实时更新的 <code class=\"language-text\">highlighted</code> 和 <code class=\"language-text\">hovered</code> 作为 props 传给所有 <code class=\"language-text\">Cell</code> 的实例.</p>\n<h2 id=\"连接器\" style=\"position:relative;\"><a href=\"#%E8%BF%9E%E6%8E%A5%E5%99%A8\" aria-label=\"连接器 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>连接器</h2>\n<p>DnD 的底层(HTML5-backend)处理了 DOM 事件, 然而我们的组件本身却是使用 React 来描述 DOM 的, 那么底层是怎么知道应该监听哪一个 DOM 节点的呢? 答案是 <em>连接器(connectors)</em> . <strong>连接器允许用户在 <code class=\"language-text\">render</code> 函数中为 DOM 节点分配一系列预先定义好的角色(拖拽元素, 拖拽预览图, 可承载拖拽元素的区域).</strong></p>\n<p>实际上, 连接器是传入<em>收集器函数</em>的第一个参数. 看下面的代码例子, 我们应该如何用连接器来声明可承载拖拽元素的区域.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">collect</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">connect<span class=\"token punctuation\">,</span> monitor</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    highlighted<span class=\"token operator\">:</span> monitor<span class=\"token punctuation\">.</span><span class=\"token function\">canDrop</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    hovered<span class=\"token operator\">:</span> monitor<span class=\"token punctuation\">.</span><span class=\"token function\">isOver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    connectDropTarget<span class=\"token operator\">:</span> connect<span class=\"token punctuation\">.</span><span class=\"token function\">dropTarget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在组件的 <code class=\"language-text\">render</code> 方法中, 我们能同时获取到监视器暴露出的数据和连接器暴露出的函数:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> highlighted<span class=\"token punctuation\">,</span> hovered<span class=\"token punctuation\">,</span> connectDropTarget <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">connectDropTarget</span><span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">className</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token function\">classSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      <span class=\"token string\">'Cell'</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Cell--highlighted'</span><span class=\"token operator\">:</span> highlighted<span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'Cell--hovered'</span><span class=\"token operator\">:</span> hovered\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>调用 <code class=\"language-text\">connectDropTarget</code> 方法后, React DnD 就能够知道组件对应的根 DOM 节点是否为合法的可拖拽区域, 同时, 组件的拖拽和鼠标悬停事件也应该被 DnD 底层处理. 实际的工作原理是, DnD 会给用户的 React 组件关联一个<a href=\"https://zh-hans.reactjs.org/docs/forwarding-refs.html#gatsby-focus-wrapper\">回调 ref</a> . 同时, 连接器返回的函数能够被缓存下来, 因此也不会影响 <code class=\"language-text\">shouldComponentUpdate</code> 的优化效果.</p>\n<h2 id=\"拖拽元素和拖拽目标\" style=\"position:relative;\"><a href=\"#%E6%8B%96%E6%8B%BD%E5%85%83%E7%B4%A0%E5%92%8C%E6%8B%96%E6%8B%BD%E7%9B%AE%E6%A0%87\" aria-label=\"拖拽元素和拖拽目标 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>拖拽元素和拖拽目标</h2>\n<p>至此, 我们对 DnD 底层进行了介绍, 它们的主要工作是与 DOM 和数据进行交互, 交互的媒介就是我们的项目, 类型, 收集器函数, 监视器和连接器, 通过这些媒介, 我们就可以描述 React DnD 应该把哪些属性注入到我们的组件中.</p>\n<p>那么, 应该如何配置我们的组件, 以确保那些属性确实被注入了呢? 如果我们希望针对拖拽事件执行一些副作用操作, 又该怎么办呢? 这时候就要依赖拖拽元素(<em>drag sources</em> )和拖拽目标 (<em>drag targets</em>) 了. 这两者是 React DnD 中最重要的两个抽象单元. <strong>它们将类型, 项目, 副作用, 收集器函数与我们的 React 组件进行关联.</strong></p>\n<p>如果你希望应用中某个组件或者某个部分是可拖拽的, 你需要将这个组件声明为<em>drag source 拖拽元素</em>. 每个拖拽元素在被声明的同时也会被注册为某个<em>类型</em>, 同时, 用户还需要实现一个方法, 该方法的功能是, 能够根据组件的属性决定生成一个特定类型的<em>项目</em>. 除了上述必须实现的方法之外, 用户还可以声明一些可选方法. 声明拖拽元素的同时还可以直接为该元素声明<em>收集器函数</em>.</p>\n<p>拖拽目标和拖拽元素很像. 它们区别就是单个拖拽目标一次可能会被注册多个类型, 同时拖拽目标的功能不是生成一个项目, 而是承载拖拽元素.</p>\n<h2 id=\"底层\" style=\"position:relative;\"><a href=\"#%E5%BA%95%E5%B1%82\" aria-label=\"底层 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>底层</h2>\n<p>React DnD 基于 <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_and_drop\">HTML5 drag and drop API (HTML5 拖拽 API)</a> 实现. 将其作为默认实现是十分合理的, 因为它在拖拽状态的预览效果就是被拖拽元素本身的样式, 用户不需要再对预览的效果做额外的处理实现. 同时, 这个 API 也是唯一处理文件拖拽事件的 API.</p>\n<p>但是 HTML5 拖拽 API 有一些缺陷, 它不支持触摸屏. 同时在 IE 浏览器中还存在一些兼容性问题, 因此在 IE 中可以扩展的功能相比其他浏览器也比较少.</p>\n<p>于是, React DnD 以<strong>插件化的方式实现了对 HTML5 拖拽 API 的依赖.</strong> 你可以选择不依赖该 API, 基于浏览器的触摸事件和鼠标事件等, 自己去实现拖拽的功能. 这种插件化的实现方式, 在 React DnD 中, 被称为<em>底层</em>. 目前 React DnD 所配套的底层是 <a href=\"https://react-dnd.github.io/react-dnd/docs/backends/html5\">HTML5 backend</a>.</p>\n<p>React DnD 底层的作用和 React 的合成事件系统有点类似: <strong>都处理了原生的 DOM 事件并抹平了各个浏览器之间的差异(兼容性问题).</strong> 尽管有这些类似之处, 但是 React DnD 并不依赖 React 以及它的合成事件. 本质上来说, React DnD 底层所做的工作就是将 DOM 事件翻译成内部的 Redux action, 以便 React DnD 对这些 DOM 事件进行处理. </p>\n<h2 id=\"hooks-和装饰器\" style=\"position:relative;\"><a href=\"#hooks-%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8\" aria-label=\"hooks 和装饰器 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hooks 和装饰器</h2>\n<p>现在你已经了解了 React DnD 的一些重要概念, 它们包括:</p>\n<ul>\n<li>Item 对象和 types</li>\n<li>由 flux 表达的 DnD 状态</li>\n<li>监视 DnD 状态的监视器</li>\n<li>将监视器输出的内容转换为组件可以消费的 props 的收集器函数</li>\n<li>将 DnD 的状态与 DOM 节点连接的连接器</li>\n</ul>\n<p>想要在我们的组件中使用以上内容, 有两个选择, 一个是使用<a href=\"https://react-dnd.github.io/react-dnd/docs/api/hooks-overview\">基于 hooks</a> 实现的 API, 一个是使用<a href=\"https://react-dnd.github.io/react-dnd/docs/api/decorators-overview\">基于装饰器</a>的 API.</p>","headings":[{"value":"项目与类型","id":"项目与类型","depth":2},{"value":"监视器","id":"监视器","depth":2},{"value":"连接器","id":"连接器","depth":2},{"value":"拖拽元素和拖拽目标","id":"拖拽元素和拖拽目标","depth":2},{"value":"底层","id":"底层","depth":2},{"value":"Hooks 和装饰器","id":"hooks-和装饰器","depth":2}],"timeToRead":7,"wordCount":{"words":363},"frontmatter":{"toc":true,"title":"React DnD 文档翻译 - 概览","date":"June 02, 2021","description":"React DnD Overview","draft":false}},"previous":{"fields":{"slug":"/usedelegate-hook/"},"frontmatter":{"title":"实现一个事件委托 hook"}},"next":null},"pageContext":{"id":"ab0a1229-65c7-5ab8-8fca-1c2ac131050b","previousPostId":"8cc0ec57-59a5-5eaf-83d8-bf3a92cfd410","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"]}